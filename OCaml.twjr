\input texinfo   @c -*- mode: texinfo -*-

@c FILE    OCaml.twjr
@c VERSION 0.0.5
@c DATE    2018-11-14T002:30
@c AUTHOR  wlharvey4

@c *****************************************************************************
@c %**start of header

@setfilename  OCaml.info
@settitle     OCaml Language

@c %**end of header
@c *****************************************************************************

@c -----------------------------------------------------------------------------
@set TITLE      About the OCaml Language
@set SHORTTITLE Version 4.07.1
@set AUTHOR WLHarvey4
@set EDITION 0.1
@set UPDATE-MONTH NOVEMBER 2018 @c goes in the subtitle
@set COPYRIGHT-YEAR 2018
@set COPYRIGHT-HOLDER WLHarvey4
@set ADDRESS1 Address Line 1
@set ADDRESS2 Address Line 2
@c -----------------------------------------------------------------------------








@c *****************************************************************************
@c BIBCITE MACROS
@c *****************************************************************************

@c need to load macros before header
@macro mybibsetrefnode{node}
@set mybibrefnode \node\
@end macro

@macro mybibnode{}
@value{mybibrefnode}
@end macro

@macro mybibusetable{node}
@set mybibtable true
@ifset mybiblist
@clear mybiblist
@end ifset
@mybibsetrefnode{\node\}
@end macro

@macro mybibuselist{node}
@set mybiblist true
@ifset mybibtable
@clear mybibtable
@end ifset
@mybibsetrefnode{\node\}
@end macro

@macro mybibcite{ref}
@inlineifclear{mybibrefnode, @mybibmakeref{mybibsetrefnode was not used, \ref\}}
@ifset mybibrefnode
@mybibmakeref{@mybibnode{}, \ref\}
@end ifset

@end macro

@macro mybibmakeref{node, ref}
(See item @cite{\ref\} in @ref{\ref\,,\node\}.)
@end macro

@macro mybibitem{ref}
@ifclear mybiblist
@ifclear mybibtable
@set mybiblist true
@end ifclear
@end ifclear

@ifset mybiblist
@item
@anchor{\ref\}[\ref\]
@end ifset

@ifset mybibtable
@item @anchor{\ref\}\ref\ ---
@end ifset

@end macro

@mybibusetable{Bibliography}

@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c FINALOUT / DRAFT / FORPRINT
@c *****************************************************************************

@set      DRAFT @i{DRAFT} @c when set, print DRAFT in heading
@c @clear DRAFT  @c when clear, don't print DRAFT in heading
@clear  FINALOUT @c when clear, show black boxes for overfull lines
@c @set FINALOUT @c when set, don't show black boxes for overfull lines
@clear  FORPRINT @c when clear, PDF output is for viewing, not printing
@c @set FORPRINT @c when set, PDF output is for printing, not viewing

@c -----------------------------------------------------------------------------
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear

@iftex
@ifset FINALOUT @c don't show black boxes for final printout
@finalout
@end ifset
@end iftex

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@ifset FORPRINT
@ifset FINALOUT
@c @setchapternewpage odd
@end ifset
@end ifset

@c -----------------------------------------------------------------------------








@c *****************************************************************************
@c SECTIONING / INDICES
@c *****************************************************************************

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook


@c merge the function and variable indices into the concept index do so without
@c the code  font, and in the  index entries do the  font management ourselves.
@c Also  merge in  the chunk  definition and  reference entries,  which jrweave
@c creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c SPECIAL TEXIWEBJR COMMANDS
@c *****************************************************************************

@c Change how xref titles are quoted.
@dquotexrefs
@c And let braces in index entries work.
@allowindexbraces

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex


@c -----------------------------------------------------------------------------
@c INITIAL_SETUP
@c -----------------------------------------------------------------------------

@c The initial_setup code runs as a script in a BEGIN section of AWK during the
@c tangling  phase before  any files  are  extracted. Here  create a  directory
@c structure for project  files, plus any other initialization  that might need
@c to be done. Files are moved into directories in a @post_create command.

@initial_setup
printf "${YELLOW}In initial_setup...${BLUEBOLD}\n"

ROOT=${PWD}
FILES="files"
SUBDIRS="src doc tst bin"

for subdir in ${SUBDIRS}
do
    ! [ -d ${ROOT}/${FILES}/${subdir} ] && {
       mkdir -vp ${ROOT}/${FILES}/${subdir} && \
       printf "${BLUEBOLD}created directory ${PURPLEBOLD}."$(basename ${ROOT})"/${FILES}/${subdir}${CLEAR}\n" || \
      printf "${RED}failed to create directory ${PURPLEBOLD}${ROOT}/${FILES}/${subdir}${CLEAR}\n"
    } || \
      printf "${BLUEBOLD}file ${PURPLEBOLD}."$(basename ${ROOT})"/${FILES}/${subdir} exists${CLEAR}\n"
done

printf "${YELLOW}Looking for ${CYAN}git repo...${CLEAR}"
if ! [ -e ./.git ]
then
        printf "${BLUE}initializing git repo${PURPLE}\n"
        printf "${REDBOLD}NOTE: ${BLUEBOLD}Initialization of the .git repo is disabled in the template.${CLEAR}\n"
        # git init
        [ -e ./.git ] && \
          printf "${GREEN}git initialized.${CLEAR}\n" || \
          printf "${RED}failed to initialize git.${CLEAR}\n"
else
        printf "${GREEN}found ${PURPLEBOLD}.git.${CLEAR}\n"
fi

printf "${YELLOW}looking for ${CYAN}.gitignore...${CLEAR}"
if ! [ -e ./.gitignore ]
then
        printf "${BLUE}creating...${CLEAR}"
        printf "\n${REDBOLD}NOTE: ${BLUEBOLD}Creation of a .gitignore file is disabled in the templated.${CLEAR}\n"
        # echo '.lodestone' > ./.gitignore
        [ -e ./.gitignore ] && \
          printf "${GREEN}created${PURPLEBOLD}.gitignore${CLEAR}\n" || \
          printf "${RED}failed${CLEAR}\n"
else
        printf "${GREEN}found ${PURPLEBOLD}.gitignore.${GREEN}\n"
fi

printf "${GREEN}initial setup done.${CLEAR}\n"

@end initial_setup
@c <------------------------------------->


@c END Special TexiwebJr Commands
@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN PRINTED MATTER
@c --COPYING
@c --FRONT MATTER
@c   **TITLE PAGES
@c     ..Short Title
@c     ..Title Page
@c     ..Copyright Page
@c --MAIN MATTER
@c   **Top
@c     --- unpaginated ---
@c     ..General Introduction
@c     ..Menus
@c     ..Table of Contents
@c     --- paginated --- unnumbered ---
@c     ..Front Matter
@c       ~~Forward
@c       ~~Preface
@c     --- paginated --- numbered ---
@c     ..Main Matter
@c       ~~Chapters
@c         >>Sections
@c           ^^Subsections
@c             ##Subsubsections
@c     --- paginated --- lettered ---
@c       ~~Appendices
@c --BACK MATTER
@c   --- paginated --- unnumbered ---
@c   **Lists (Unnumbered)
@c     ..Bibliography
@c     ..Tables
@c     ..Indices
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN COPYING
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


@copying

@c <------------------------------------->
@docbook
<para>Published by:</para>

<literallayout class="normal">Full Name
Address Line 1
Address Line 2
etc.
Email: <email>user@@example.com</email>
URL: <ulink url="http://www.example.com/">http://www.example.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; YYYY, YYYY
Full name here
All Rights Reserved.</literallayout>
@end docbook
@c <------------------------------------->


@c <------------------------------------->
@ifnotdocbook
Copyright @copyright{} @value{COPYRIGHT-YEAR} @*
@value{COPYRIGHT-HOLDER} @*
All Rights Reserved.
@end ifnotdocbook
@c <------------------------------------->


@sp 1
The @value{TITLE} is copyrighted @copyright{} @value{COPYRIGHT-YEAR} by
@value{COPYRIGHT-HOLDER}.  It is published under the conditions of the GNU
General Public License, version 3.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.


@end copying
@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN TITLEPAGE
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


@titlepage

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@title @value{TITLE}
@subtitle @value{SHORTTITLE} Edition @value{EDITION} (@value{UPDATE-MONTH})
@author @value{AUTHOR}

@c <------------------------------------->
@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
@value{AUTHOR} @*
@value{ADDRESS1} @*
@value{ADDRESS2} @*
@* @c etc.
Email: @EMAIL{user@@example.com,user AT example.com} @*
URL: @url{http://www.example.com/} @*

@insertcopying
@end ifnotdocbook
@c <------------------------------------->

@end titlepage

@c /////////////////////////////////////////////////////////////////////////////








@c =============================================================================
@c HEADINGS SETTINGS
@c =============================================================================

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @value{DRAFT} @| @thispage
@end iftex

@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN TOP
@c --General Introduction
@c --Main Menu
@c --Table of Contents
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%








@ifnottex
@ifnotdocbook
@ifnotxml

@c =============================================================================
@node Top
@top The OCaml Language
@c =============================================================================

This file documents @value{TITLE}, a program that does @dots{}.

@insertcopying

@end ifnotxml
@end ifnotdocbook
@end ifnottex




@c -----------------------------------------------------------------------------

@c <------------------------------------->
@c                MENUS

@menu

@detailmenu

@end detailmenu
@end menu
@c <------------------------------------->


@c <------------------------------------->
@c                 TOC

@c @summarycontents
@contents
@c <------------------------------------->


@c -----------------------------------------------------------------------------


@c END Menus and Contents
@c /////////////////////////////////////////////////////////////////////////////







@c <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
@part Front Matter
@c <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>






@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN FRONT-MATTER
@c --Forward
@c --Preface
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%








@c *****************************************************************************
@c                                 FORWARD

@c @node Foreword
@c @unnumbered Foreword


@c END Forward
@c /////////////////////////////////////////////////////////////////////////////








@c *****************************************************************************
@c                               PREFACE

@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN Preface
@c --Audience
@c --Overviw
@c --Conventions
@c --Acknowledgements
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@node Preface
@unnumbered Preface

Text here.

@menu
* Audience::                    Who should read this @value{DOCUMENT}.
* Overview::                    An overview of the @value{DOCUMENT}.
* Conventions::                 Typographical conventions.
* Acknowledgements::            Acknowledgements.
@end menu




@c -----------------------------------------------------------------------------

@node Audience
@unnumberedsec Intended Audience

Who should read  this document?  First, what is literate  programming? To begin
this conversation, it is just as important to understand what it is not as what
it is. It is @emph{not}  @b{documentation}.  It is, rather, a @emph{programming
paradigm}, or  perhaps a @emph{programming  meta-language} sitting on top  of a
conventional programming language.  Here are a few quotes to set the context:

@quotation
@sansserif{Read your  first page: YOU  GOT IT TOTALLY  WRONG. Literate
programming is NOT about documentation in the first place.  All quotes
you  tore  out  speak  of  literate programming  as  if  it's  just  a
documentation system.  While it is not.}

@sansserif{Literate programming  is a PROGRAMMING PARADIGM,  or if you
wish a "META-LANGUAGE",  on top of machine-coding  language, which was
created with the purpose of: a) allowing humans to create abstractions
over abstractions over abstractions with  macros (which are phrases in
a human language  and if you wish are precise  "new operators" in that
meta-language, created  on the fly). b)  this system of macros  can be
created  not  in machine  demanded  order,  but  as need  for  logical
thinking.   Later  it  is  reshuffled  ("tangled",  i.e.   convoluted,
scrambled) from the natural into the inhuman machine codes.}

@sansserif{You  totally missed  the idea,  and  in the  case of  blind
leading  the   blind  quote  scores  of   other  misreaders.  Literate
programming is not  a documentation system per se,  it's a programming
paradigm.}

@author Astonished Reader @mybibcite{LitProg:Home}
@end quotation

It is literature  teaching people about a  very complex system, i.e.,  a set of
symbols intended for  humans about a set  of symbols intended for  a machine to
interpret and turn into action.

@quotation
@sansserif{Let us change our  traditional attitude to the construction
of programs: Instead of imagining that  our main task is to instruct a
computer what to do, let us  concentrate rather on explaining to human
beings what we want a computer to do.}
@author Donald Knuth @mybibcite{LitProg:Knuth}
@end quotation

@quotation
@sansserif{Literate programming  is the art of  preparing programs for
human readers.}
@author Norman Ramsey @mybibcite{LitProg:Ramsey}
@end quotation

Literate programming  is a  programming paradigm  or meta-language  that allows
greater abstraction than the programming language itself; it is a paradigm that
is based  upon the logical needs  and understandings of the  programming author
speaking to programming  readers (including him or herself), while  at the same
time,  in parallel,  it is  a  paradigm or  meta-language designed  to allow  a
computer system to  @emph{tangle} the programming author's ideas  into a system
that  is understood  and  processed by  a machine  according  to the  machine's
requirements: machine code.

In the case  of literate programming via the  @file{TexiWebJr} system, however,
there is the added advantage that  during the @emph{weaving} process the author
is producing two  dual abstractions for readers: @b{nodes}  (via an @file{Info}
file)  and  @b{sectioning}  (via   a  hyperlinked  @file{Pdf}  document),  each
inherently independent  yet working in concert  to produce at one  and the same
time  both graph-based  and chapter-based  output, each  with its  own inherent
strengths  and  advantages.  The  @file{TexiWebJr}  system  goes even  further,
however, in  producing a  third output which  is a hybrid  of both  systems, an
@acronym{HTML}  form (via  an @acronym{HTML}  web  site) that  combines both  a
sectioning output  and a graph-based  output.  You  have your choice  of graph,
sectioning, and combined,  all of which is fully  indexed and cross-referenced,
from one  source file.

It  is an  inherent aspect  of literate  programming that  there is  always one
source document,  so that by  changing any one part  of the system,  the author
updates all  forms of  output at  one and the  same time.   It is  perhaps this
aspect of  literate programming  that causes the  confusion with  thinking that
literate  programming  is  solely   about  @emph{documentation}.   In  reality,
however, that  is just one  aspect of literate  programming; the real  point of
literate programming  is that the author  can attack the problem  of creating a
complex system from an abstract logical position disconnected to a large degree
from the  requirements of  the computer  machine and present  the problem  to a
reader in a way  that will provide true understanding with  less effort than if
the reader had to understand the system from the computer's point of view

And finally, I use  literate programming as a form of  education.  It allows me
to  take a  complex situation  and break  it down  into hierarchies  of simpler
parts, but at  the same time provide links and  cross-references and indices to
tie the complex  system together into a web of  inter-related parts, which form
the whole.  Using this form of literate programming, I can create one big whole
system, and iteratively rework it into a web of inter-related parts that inform
my growing understanding  of the system as a whole,  while never destroying the
system's inherent  integrity to operate as  a functional machine.

In summary, I see the advantages of literate programming to be immense and that
far outweigh the  relatively high cost of  learning how to do it  (which is for
certain a life-long endeavor in itself).  Therefore, dear Reader, this document
is intended for human  consumption.  If you are a machine,  please refer to the
tangled mess that has  been prepared for you as source  code.  Whoever you are,
enjoy.  Cheers.




@c -----------------------------------------------------------------------------
@node Overview
@unnumberedsec What Is Covered

Overview text and chapter by chapter description here.


@c .....................................

@node The Readme
@unnumberedsubsec The Readme
@cindex readme

@(README.md@)=
# MY TWJR TEMPLATE

## About This Source File

This  document (`my_template.twjr`)  is  a *literate*  source  document. It  is
designed to produce an `Info` file (best read from within Emacs, but there is a
stand-alone Info  reader that can  be used),  a `Pdf` document  (generated from
LaTeX source  code by PDFTeX),  an `HTML` web  site, `Docbook` source  code, an
`XML`  document, and  a  plain text  document. In  addition.  it also  produces
working  code   in  any  language  (so   long  as  your  system   contains  the
infrastructure to  run the code). For  example, this `README` file  was drafted
within this source document  and extracted as a separate file,  as was also the
`Makefile`.  This *literate*  document's  features are  targeted  via a  custom
`Makefile` that is  also a part of  this document, and extracted  as a separate
file, and is dynamic in the sense that  if you update it, you can produce a new
version with  a simple call to  a `make` target. It  is designed to be  able to
produce any  number of working software  packages of any language  contained at
any  number of  different  locations on  your  system, all  with  a single  or,
alternatively, multiple `make` calls, depending on the granularity you need.

The Github  repository contains this  source document,  a Makefile that  can be
used  to work  with the  project, as  well as  a `Texinfo`  file that  has been
generated from  this `Twjr` file,  this README,  and a `.gitignore`  file. Most
computer systems have or can easily get the `make`, and `texinfo` programs that
are needed to  process the `Texinfo` file into the  various end documents, such
as `Info`,  `Pdf`, `HTML`, etc. Your  system will need, in  addition to `make`,
and `texinfo`, Gnu  AWK (`gawk`), and TexiwebJr to make  changes to this source
document and  process it  into a  `Texinfo` file and  extract its  programs and
files.  Your system  should also  have  the equivalent  of Bash  version 4,  as
version 4  has some parameter capabilities  that earlier versions do  not. Note
that most  versions of Mac OS  have version 3  of Bash installed as  a default.
Version 4 can be added using Homebrew or MacPorts very easily. In the past, Mac
OS has  also shipped with a  version of `texinfo`  that is below 6.5.  You will
also need to update `texinfo` to at least 6.5 if that is the case.

## How It Works

## Resources

* [TexiwebJr](https://github.com/arnoldrobbins/texiwebjr)
* [Texinfo](https://www.gnu.org/software/texinfo/)
* [Gnu AWK (gawk)](https://www.gnu.org/software/gawk/)
* [Gnu Bash](https://www.gnu.org/software/bash/)
* [TeX Live](https://www.tug.org/texlive/)

@




@c -----------------------------------------------------------------------------

@node Conventions
@unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{http://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo




@c -----------------------------------------------------------------------------

@c @node Acknowledgements
@c @unnumberedsec Acknowledgements

@c Acknowledgements go here.


@c END Preface
@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN CHAPTERS
@c --Introduction
@c --Chapters 1-1
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%








@c *****************************************************************************
@c                          CHAPTER: Introduction

@node Introduction
@chapter Introduction


@c END Chapter Introduction
@c /////////////////////////////////////////////////////////////////////////////






@c <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
@part @sc{References}
@c <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>






@c *****************************************************************************
@c                              CHAPTER ONE

@node OCaml Sites
@chapter OCaml Sites




@c -----------------------------------------------------------------------------
@c                          Section: OCAML.ORG

@node Home Site OCaml.org
@section Home Site OCaml.org
@cindex ocaml home
@cindex home of ocaml

@url{https://ocaml.org/, OCaml Home}

@quotation
OCaml  is an  industrial strength  programming language  supporting functional,
imperative and object-oriented styles.
@author The OCaml People
@end quotation

@heading A Taste of OCaml
@example
(* Binary tree with leaves carrying an integer. *)
type tree = Leaf of int | Node of tree * tree

let rec exists_leaf test tree =
  match tree with
  | Leaf v -> test v
  | Node (left, right) ->
      exists_leaf test left
      || exists_leaf test right

let has_even_leaf tree =
  exists_leaf (fun n -> n mod 2 = 0) tree
@end example


@c .....................................

@node Install OCaml
@subsection Install OCaml
@cindex install ocaml

@url{https://ocaml.org/docs/install.html, Install OCaml}

@heading Releases

@subheading 4.07 Releases

Ocaml 4.07.1 was released on 2018-10-04.

@url{https://ocaml.org/releases/4.07.1.html, 4.07.1}.

@subsubheading All 4.07 Files (Including Reference Docs)

@url{http://caml.inria.fr/pub/distrib/ocaml-4.07/}

@subheading All Earlier Releases

@url{https://ocaml.org/releases/, All Releases Here}




@c -----------------------------------------------------------------------------
@c                            Section: OPAM

@node Package Manager Site Opam.ocaml.org
@section Package Manager Site Opam.ocaml.org




@c -----------------------------------------------------------------------------
@c                          Section: CAML INRIA

@node Caml Inria Site
@section Caml Inria Site
@cindex caml inria

@url{http://caml.inria.fr/index.en.html, Caml Inria}

@heading What Is Caml?
Caml is  a general-purpose programming  language, designed with  program safety
and reliability in mind. It is very expressive, yet easy to learn and use. Caml
supports functional, imperative, and object-oriented programming styles. It has
been  developed  and distributed  by  INRIA,  a  French research  institute  in
computer science and applied mathematics, since 1985.

@heading OCaml
The OCaml system is the main implementation of the Caml language. It features a
powerful module system and a  full-fledged object-oriented layer. It comes with
a  native-code   compiler  that  supports  numerous   architectures,  for  high
performance; a bytecode compiler, for increased portability; and an interactive
loop, for experimentation and rapid development.

@heading Caml Light
The Caml Light system is an  older, lightweight implementation of the core Caml
language. It  is obsolete, no longer  actively maintained, and will  be removed
eventually. We recommend switching immediately to its successor, OCaml.

@heading Resources for Caml Users
In  addition to  the official  distribution of  the Caml  compilers, this  site
provides a collection  of online resources that are useful  to Caml users, from
beginners to  expert programmers.  Most of  them were  contributed by  the very
active community of Caml programmers.


@c .....................................

@node Additional Resources
@subsection Additional Resources

@url{http://caml.inria.fr/resources/index.en.html, Additional Resources}

@table @b
@item Reference Manuals
@itemize
@item
@url{http://caml.inria.fr/pub/docs/manual-ocaml/index.html, OCaml Manual}
@item
@url{http://caml.inria.fr/pub/docs/manual-ocaml/libref/index.html, Standard Library}
@end itemize
@item Documentation
@itemize
@item
@url{http://caml.inria.fr/resources/doc/index.en.html, Documentation Index}
@end itemize
@item Community
@itemize
@item
@url{http://ocaml.org/, OCaml Website}
@item
@url{http://caml.inria.fr/resources/forums.en.html, Forums}
@item
@url{http://caml.inria.fr/resources/logos.en.html, Logos}
@item
@url{http://caml.inria.fr/pub/old_caml_site, The Old Site}
@item
@url{http://mirror.ocamlcore.org/wiki.cocan.org/, COCAN - The OCaml Alliance Network}
@item
@url{http://mirror.ocamlcore.org/ocaml-tutorial.org/, OCaml Wiki}
@item
@url{http://planet.ocaml.org/, OCaml Blogs}
@item
@url{http://forge.ocamlcore.org/, OCaml Forge}
@end itemize
@item Caml Development
@itemize
@item
@url{http://caml.inria.fr/ocaml/release.en.html, Latest OCaml Release}
@item
@url{http://caml.inria.fr/mantis, Bug Tracking}
@item
@url{https://github.com/ocaml/ocaml, OCaml Git Repo}
@item
@url{http://alan.petitepomme.net/cwn/2018.11.06.html, Weekly News}
@end itemize

@end table


@c .....................................

@node About Caml In Depth
@subsection About Caml In Depth

@url{http://caml.inria.fr/about/index.en.html}

Caml is  a general-purpose programming  language, designed with  program safety
and reliability in mind. It is very expressive, yet easy to learn and use. Caml
supports functional, imperative, and object-oriented programming styles.

The Caml language has been developed since 1985 at INRIA by the Formel, Cristal
and Gallium teams. Caml Light, which was developed in the early 1990s, is still
in use today, especially in education. OCaml offers a richer programming
language as well as efficient native code compilers for many architectures. A
more detailed history of Caml is available.

@subheading Strengths
Both implementations of Caml offer:
@itemize
@item
@b{A  powerful type  system}, equipped  with parametric  polymorphism and  type
inference. For instance,  the type of a collection can  be parameterized by the
type of  its elements. This allows  defining some operations over  a collection
independently of  the type of  its elements: sorting  an array is  one example.
Furthermore, type inference  allows defining such operations  without having to
explicitly provide the type of their parameters and result.
@item
@b{User-definable  algebraic data  types and  pattern matching}.  New algebraic
data types can  be defined as combinations of records  and sums. Functions that
operate over  such data structures can  then be defined by  pattern matching, a
generalized form of  the well-known switch statement, which offers  a clean and
elegant way of simultaneously examining and naming data.
@item
@b{Automatic  memory management},  thanks to  a fast,  unobtrusive, incremental
garbage collector.
@item
@b{Separate  compilation   of  stand-alone  applications}.   Portable  bytecode
compilers allow  creating stand-alone applications  out of Caml Light  or OCaml
programs. A foreign function interface allows  Caml code to interoperate with C
code  when  necessary.  Interactive  use  of  Caml  is  also  supported  via  a
“read-evaluate-print” loop.
@end itemize
In addition, OCaml features:
@itemize
@item
@b{A   sophisticated   module   system},  which   allows   organizing   modules
hierarchically and parameterizing a module over a number of other modules.
@item
@b{An  expressive object-oriented  layer}, featuring  multiple inheritance  and
parametric classes.
@item
@b{Efficient  native code  compilers}. In  addition to  its bytecode  compiler,
OCaml  offers  a  compiler  that  produces  efficient  machine  code  for  many
architectures.
@end itemize

For             more             explanations,             read             our
@url{http://caml.inria.fr/about/overview.en.html, overview of the Caml language
and       tools},       see        Yaron       Minsky's       white       paper
@url{http://queue.acm.org/detail.cfm?id=2038036, OCaml for the Masses}, or have
a  look at  @url{http://caml.inria.fr/about/taste.en.html, a  hundred lines  of
Caml}.

@subheading A Widely Used Programming Language

The  Caml language  was initially  used  to develop  applications that  involve
symbolic computation:  automatic theorem  provers, compilers  and interpreters,
program  analyzers, etc.  It is  now  used to  develop software  in many  other
application   areas.   This   is   illustrated  by   our   list   of   selected
@url{http://caml.inria.fr/about/successes.en.htmlm success stories}.

The Caml  language is  widely used  for teaching programming.  It is  also used
inside  academic projects  in Europe,  Asia,  and the  Americas. Several  large
corporations develop  significant industrial  projects in OCaml:  these include
Dassault Systèmes, Microsoft, IBM, and CEA (Commissariat à l'Énergie Atomique).

The @url{http://caml.inria.fr/consortium/index.en.html, Caml consortium} offers
industrial and  academic partners a  formal framework for participating  in the
development,  maintenance, and  evolution  of Caml.  Partners  also enjoy  very
liberal licensing conditions regarding the Caml software distribution.

@subheading How to Get the Caml Compilers?

The  Caml compilers  developed  at INRIA  are Open  Source  software. They  are
available free of charge.

@itemize
@item
You   can  @url{http://caml.inria.fr/download.en.html,   download  the   latest
versions} off this site.
@end itemize


@c .....................................

@node Alternate Download Site
@subsection Alternate Download Site

@url{http://caml.inria.fr/download.en.html}

The most  recent version  of OCaml  is 4.06.0. It  was released  on 2017-11-03.
Further   information    and   download   links    can   be   found    on   the
@url{http://caml.inria.fr/ocaml/release.en.html, release page}.

@table @b
@item Source distribution for Unix systems (including Linux, MacOS X, and Cygwin)
@itemize
@url{http://caml.inria.fr/pub/distrib/ocaml-4.06/ocaml-4.06.0.tar.gz,   Gzipped
tarball}
@item
@url{http://caml.inria.fr/pub/distrib/ocaml-4.06/ocaml-4.06.0.tar.xz,   Xzipped
tarball}
@end itemize
@item Binary distribution for MacOS X
We do not distribute  MacOS binaries any more. You should  install OPAM and use
it to install OCaml.
@item Documentation and User's manual
@itemize
@item
Single document in PostScript,
@url{http://caml.inria.fr/pub/distrib/ocaml-4.06/ocaml-4.06-refman.pdf, PDF} or
@url{http://caml.inria.fr/pub/distrib/ocaml-4.06/ocaml-4.06-refman.txt, plain
text}.
@item
Bundle of HTML files in a
@url{http://caml.inria.fr/pub/distrib/ocaml-4.06/ocaml-4.06-refman-html.tar.gz,
TAR} or
@url{http://caml.inria.fr/pub/distrib/ocaml-4.06/ocaml-4.06-refman-html.zip,
ZIP archive}.
@item
Bundle of Emacs info files in a
@url{http://caml.inria.fr/pub/distrib/ocaml-4.06/ocaml-4.06-refman.info.tar.gz,
TAR archive}.
@end itemize
@item Download directory
All the files are also available in
@url{http://caml.inria.fr/pub/distrib/ocaml-4.06, this
directory}http://caml.inria.fr/pub/distrib/ocaml-4.06, along with their MD5
checksums.
@end table



@c END Chapter First
@c /////////////////////////////////////////////////////////////////////////////






@c *****************************************************************************
@c                          CHAPTER: OcamlMOOC

@node OcamlMOOC
@chapter OcamlMOOC
@cindex ocamlmooc

@heading Introduction to Functional Programming in OCaml

@cindex functional programming paradigm
Functional programming  is a programming  paradigm which is  rapidly attracting
interest  from  a  broad  range  of  developers  because  it  allows  to  write
expressive, concise and elegant programs.

In this MOOC you will learn  Functional programming using the OCaml programming
language.You will  discover the powerful  mechanisms that are offered  to build
and manipulate  complex data structures in  a clean and efficient  way. And you
will see how functions  play a central role, as first-class  values that can be
freely used in any place where an expression can appear.

@cindex Robin Milner
@cindex ML
The OCaml programming language is a  member of the ML language family pioneered
by  Robin Milner.  An important  feature  of OCaml  is that  it reconciles  the
conciseness and flexibility of untyped  programming languages (like Python, for
example) with  the safety of  strongly typed programming languages  (like Java,
for example).  The OCaml compiler performs  in fact a type  inference. Types of
identifiers do not have to be declared  but are inferred by the compiler at the
moment  of  definition of  an  identifier,  and  then  used for  assuring  type
correctness when using an identifier.

@cindex multi-paradigm language
We will  start by using OCaml  as a purely functional  programming language. At
the  end of  this MOOC  we will  see  that OCaml  is in  fact a  multi-paradigm
language which allows you to combine  the functional programming style with the
imperative programming paradigm.




@c -----------------------------------------------------------------------------
@c                          SECTION: About

@node Outline of the Course
@section Outline of the Course

@heading Weeks and Sequences
@itemize

@item
an introduction to functional programming

@item
using the state-of-the-art OCaml programming language

@item
exploiting an exercise environment right  in your browser using ground-breaking
technology based on OCaml itself

@item
seven weeks

@enumerate 0
@item
 Introduction and overview

@enumerate

@item
sequence 1 Functional Programming: history and motivation

@item
sequence 2 The OCaml language: history and key features

@item
sequence 3 Why the OCaml language: meet the users

@item
sequence 4 Tools and development environment: first steps in OCaml!

@item
sequence 5 A brief showcase of some of OCaml’s features

@item
sequence 6 Overview of the available resources

@end enumerate


@item
 Basic types, definitions and functions

@item
 Basic data structures

@item
 More advanced data structures

@item
 Higher order functions

@item
 Exceptions, input/output and imperative constructs

@item
 Modules and data abstraction
@end enumerate


@item
one hour of course per week in several short video sequences

@item
numerous exercices, checked for you right in your browser

@item
optional additional material  to learn more about OCaml’s  advanced, real life,
industrial applications

@item
a final full-fledged programming exercise
@end itemize

@heading Learning Objectives
@itemize

@item
learn to program using the functional style

@item
know the basics of OCaml’s advanced type-system

@item
discover the  power of the  concise manipulation  of user defined  complex data

@item
structuresstart to explore OCaml’s rich and powerful features

@item
discover OCaml’s dynamic and growing ecosystem
@end itemize




@c -----------------------------------------------------------------------------

@node News Updates
@section News Updates
@cindex news


@c .....................................

@node SEPTEMBER 17 2018
@subsection SEPTEMBER 17, 2018

We  are  happy  to welcome  you  to  this  MOOC  on functional  programming  in
OCaml. This is the  third session of the course, that was  first run in October
2015, and has been improved taking into account the feedback we received.

This  starting week  is composed  of  two chapters,  named  week 0  and week  1
respectively,  and is  a kind  of  a warm  up.  Take your  time to  familiarize
yourself  with the  FUN platform,  the  grading environment,  and the  internal
forum. For instance, what about introducing yourself, your motivations, or your
expectations in the Coffee room section of the internal forum ?

In the  first chapter, namely "Introduction  and overview", you will  find some
history and motivation behind Functional Programming, and learn about the OCaml
ecosystem in general. But, let's start this  MOOC with a greetings video by our
guest Xavier Leroy!

In the  first chapter, namely "Introduction  and overview", you will  find some
history and motivation behind Functional Programming, and learn about the OCaml
ecosystem in  general. This  MOOC starts  with a greetings  video by  our guest
Xavier Leroy, the creator of the OCaml language!

In the first part  of the second chapter, you will learn how  to use OCaml as a
(very  rigorous and  expressive)  calculator, writing  simple expressions  over
basic data types. For this part, you  will be able to test your knowledge using
quizzes. There  is a lot of  quizzes but only half  of them count in  the final
grade; so don't be  afraid and do not let them drive you  crazy! You might also
skip them  and come back  later. Their purpose is  mostly to let  you challenge
your  knowledge   of  various   corner  cases---well   lets  say   oddities  or
originalities---in the  OCaml syntax  than to blame  mistakes: for  each graded
quizz, you  have three  attempts and  some hints are  provided after  the first
attempt.

Then, in the second part, you will learn how to write your first functions. You
will be able to test your  knowledge using actual programming exercises, in the
integrated grading  environment. Patience, this  will be much less  boring than
the quizzes!

In this second part,  there is also a video from  Kathleen and Arthur Breitman,
the creators  of Tezos, one of  the most innovative blockchain.  You will learn
why they decide to make the infrastructure of Tezos crucially depends on OCaml.

All programming  exercises count into the  final grade (except, each  week, the
exercise with  the lowest grade)  but there is no  limitation in the  number of
submissions. You have until  the end of the course to  submit your answers, and
you can observe your progression in the Progress tab.

And, as our guest star Xavier Leroy says, have fun!


@c .....................................

@node SEPTEMBER 24 2018
@subsection SEPTEMBER 24, 2018

Hello and welcome to the second week of this course.

Last week, you  learned how to write simple expressions  over basic data types,
and  how  to  write  simple  and even  recursive  functions.  We  continue  our
exploration  of the  OCaml  programming  language :  you  will manipulate  data
structures built using  those previously introduced basic data  types, but also
learn to define and  use your own types so they best fit  the problems you want
to solve with functional programming.

With data types that can contain one or  more basic values, you will be able to
solve small puzzles in the exercises, and finally to implement a small database
that leverages the type safety of OCaml.

This week too, we have a welcome video message. This time, it is from OCamlPro,
the guys who did most of the technical support for this MOOC!

Have fun!


@c .....................................

@node OCTOBER 01 2018
@subsection OCTOBER 01, 2018

At this point in the course, you should  be able to use data structures such as
tuples, records, or arrays to solve  small problems. The final exercise of last
week, about a  typed database, is a  good test to actually use  all you learned
since the beginning of this course.

This week, you will learn more about  defining your own datatypes, and use them
in conjunction with recursion. This will enable you to write programs that take
full advantage of  the combination of these  two features, which is  one of the
bigger strength of functional programming.

Enjoy this new week's content and get ready for a new set of exercises!


@c .....................................

@node OCTOBER 08 2018
@subsection OCTOBER 08, 2018

This week  we are  going to  explore what can  be done  when one  starts taking
seriously the  possibility of functions  as first  class citizens, that  can be
passed as arguments, or computed  as results. Higher order functions (functions
that can take  functions as arguments, and  return them as results)  are at the
core of  functional programming: they  provide an  elegant and powerful  way of
solving and thinking  about problems. They allow to define  computations on the
data structures  we have seen  last weeks  by reasoning about  those structures
instead of defining concrete steps that change the state of the data.


@c .....................................

@node OCTOBER 15 2018
@subsection OCTOBER 15, 2018

Until now, we've mainly used OCaml  to perform "pure" computations, that do not
have  side  effects  or  interactions  with the  environment.  For  real  world
programs, one  have to deal  with computations  that have side  effects, handle
exceptional behavior  using exceptions,  and get  information in  and out  of a
program, ...

With side effects  also come mutations. The OCaml  programming language offers,
additionally to the functional style,  some imperative constructs that allow to
easily  write  the  algorithms  that  happen  to  be  more  naturally  or  more
efficiently implemented in an imperative style.


@c .....................................

@node OCTOBER 22 2018
@subsection OCTOBER 22, 2018

Welcome to  the final week  of this course  of functional programming  with the
OCaml language!

Up to now, we have explored most  of the core features of OCaml: writing simple
expressions or higher order functions, manipulating complex data structures, or
handling side effects and exceptions have  now become familiar to you. It's now
time  to see  how to  structure your  OCaml code  when you  write longer,  more
complex programs, and how to create  the data abstractions that are needed when
programming in  the large: modules  are a  great language construct  that OCaml
makesavailable just for  that, and we are  going to explore them  this week. We
will also  survey some of the  OCaml tools, so that  you will be able  to write
your first  real world OCaml projects,  outside of the exercise  environment in
the web browser  that has accompanied us  all along the course And  as an added
bonus, you  can watch these two  last guest videos from  companies and projects
that found OCaml essential for their developments!

Remember: next week we will unveil the final project!


@c .....................................

@node OCTOBER 29 2018
@subsection OCTOBER 29, 2018

Welcome to the final project: the time has  come to try your hands on some real
programming task!

To finish the course, we offer you a choice among two projects.

@enumerate
@item
In the first, A Solver for Klotski,  you will write a generic solver for puzzle
games,  and then  instanciate it  to solve  the game  of Klotski.  You will  be
rewarded with an  animation of your solution! This project  uses vocabulary and
concepts  that make  it  more suited  for computer  science  students.

@item
In the  second, Random Text  Generation, you will write  a program that  uses a
Markov chain  approach (yes,  the same Markov  chains as in  the TV  series) to
generate random  sentences that reuse  parts of an  input text corpus  (or even
mixes  parts  of several  ones).   You  will be  rewarded  with  lots of  funny
sentences!  This project  is a  bit easier  and has  less prerequisites.   Both
projects can be done using the integrated  OCaml environment. So have a look at
both texts and  choose the one you prefer!  You can also do both,  but it won't
give you extra points.
@end enumerate


@c END SECTION News
@c /////////////////////////////////////////////////////////////////////////////




@c -----------------------------------------------------------------------------
@c                          SECTION: Week 0

@node Week 0 Introduction And Overview
@section Week 0 Introduction And Overview
@cindex week 0

@heading About
In this first part of the first week, we review some history and motivation for
Functional  Programming,  learn  about  the OCaml  ecosystem  in  general,  and
discover the available tools and resources.

@cindex Xavier Leroy
@subheading Greetings
Greetings from Xavier Leroy.

@subheading Introduction to the course
This sequence  provides a general overview  of the course, its  motivation, and
the overall structure of the different lectures.

@cindex functional programming
@subheading Functional Programming: history and motivation
In  this  sequence,  we  review  some history  and  motivation  for  Functional
Programming, and find out why there is so much excitement about the addition of
so-called lambdas in many programming languages.

@itemize
@cindex Church-Turing thesis
@cindex exercise
@item
Exercise: Church-Turing thesis
@end itemize

@cindex history of ocaml
@subheading The OCaml language: history and key features
In this sequence, we recall the  origins of the OCaml programming language, and
pinpoint the key features of the language.

@cindex ML family
OCaml is  a member of  the ML family of  programming languages, that  provide a
unique combination  of functional programming  with strong static  typing, type
inference and algebraic data types.

@subheading Why the OCaml language: meet the users
In this  sequence, we  let the  users of the  OCaml programming  language speak
up. We will hear voices from people participating in advanced research project,
and enterprises developing world-class industrial  applications. It is a unique
occasion to learn which features are important for them, and why.

@cindex tools
@subheading Tools and development environment: first steps in OCaml!
In  this sequence,  we provide  an overview  of the  tools and  the development
environment available  for OCaml.  Here we  introduce the  interactive exercise
environment that you  will use during the  rest of the course,  and provide you
with a guided tour of its features.

Unlike most of the development  environment used in online course, state-of-the
art technology developed around OCaml allows  us to provide an environment that
runs fully  in your browser,  using the Javascript  engine of your  browser. No
download is  needed, and  no remote  server is  hidden behind  your interactive
development  environment! Notice  that you  need a  recent browser:  we suggest
Chrome or Firefox, possibly the latest version.

@itemize
@cindex exercise
@item
Exercise: Grading environment (test-bed)
@end itemize

@subheading A brief showcase of some of OCaml's features
In this  sequence, we offer a  preview of some  of the amazing features  of the
OCaml programming language. Do not try  to fully understand the precise details
of the code shown:  you will master them all by the end  of the course. What is
important to get here  is the feeling of the power that  can be unleashed using
OCaml.

@cindex resources
@subheading Overview of the available resources
In this sequence, we will briefly  review the main available resources that are
relevant  for taking  full advantage  of the  course. You  will also  find here
pointers for reaching out to the great OCaml community.






@c ----------------------------------------------------------------------------
@c                          SECTION: Week 1

@node Week 1 Basic Types Definitions And Functions
@section Week 1: Basic Types, Definitions And Functions
@cindex week1
@cindex basic types
@cindex definitions
@cindex functions

@heading About
In this second  part of the first  week, we learn the basic  features needed to
write our first functions.

@heading Tezos (video)
Tezos


@c .....................................

@node Basic Data Types
@subsection Basic Data Types
@cindex basic data types
@cindex data types, basic

@heading About
This sequence introduces  two important primitive types of  OCaml: integers and
booleans.


@c .....................................

@node More Data Types
@subsection More Data Types
@cindex data types, more
@cindex primitive types
@cindex floats
@cindex characters
@cindex strings
@cindex conversion functions between types

@heading About
In this  sequence we introduce  some more primitive types:  floats, characters,
and strings. We also talk about conversion functions between different types.


@c .....................................

@node Expressions
@subsection Expressions
@cindex expressions

@heading About
Expressions  compute   values,  they   play  a   central  role   in  functional
programming.  This  sequence shows  some  basic  constructions of  expressions:
conditionals  and  function   application.  We  also  show   some  examples  of
polymorphic operators.


@c .....................................

@node Definitions
@subsection Definitions
@cindex definitions
@cindex identifiers
@cindex bind values
@cindex local vs global definitions
@cindex simultaneous definitions

@heading About
Definitions  introduce names  of identifiers,  and  bind values  to them.  This
sequence  explains the  two forms  of definitions  in OCaml,  namely local  and
global definitions, and shows why simultaneous definitions are useful.


@c .....................................

@node Functions
@subsection Functions
@cindex functions
@cindex function definitions
@cindex definition of functions
@cindex lexical scoping

@heading About
In functional  programming, functions are the  basic means to structure  and to
generalize  code.  This  sequence  shows   some  simple  examples  of  function
definitions  in OCaml.  We also  discuss the  fundamental principle  of lexical
scoping, and  demonstrate that identifiers  are not  variables in the  sense of
imperative programming.


@c .....................................

@node Recursion
@subsection Recursion

@heading About
This sequence  explains how  to define  in OCaml  recursive functions,  that is
functions that in their definition call themselves.




@c -----------------------------------------------------------------------------
@c                        SECTION: Week 2

@node Week 2 Basic Data Structures
@section Week 2: Basic Data Structures
@cindex week 2
@cindex basic data structures
@cindex data structures, basic
@cindex flat data structures
@cindex data structures, flat

@heading About
This week and the  next one, we will learn how to structure  code and data with
types. Types are not only useful  to document programs using type abbreviations
(sequence 0) but also to inform the  compiler about the shape of values so that
it can statically check that they are  properly used. This week will be devoted
to flat data like tuples (sequence 1), records (sequence 2) or arrays (sequence
3). A toy typed database will be implemented during sequence 4.

@subheading Greetings (Video)
Greetings from OCamlPro.


@c .....................................

@node User-defined Types
@subsection User-defined Types
@cindex user-defined types
@cindex types, user-defined

@heading About
Types   are   useful  to   document   a   program   because  they   attach   an
application-specific meaning  to a set  of values.  A type abbreviation  is the
simplest  way  to  introduce  types  in  programs  by  binding  a  user-defined
identifier  to a  type. In  this sequence,  we will  learn the  syntax of  type
definitions and how to write type annotations.


@c .....................................

@node Tuples
@subsection Tuples
@cindex tuples
@cindex aggregate type, tuple

@heading About
The simplest way to  aggregate several values is to join them  in a tuple. This
sequence introduces the syntax for constructing and observing tuples.


@c .....................................

@node Records
@subsection Records
@cindex records
@cindex record types
@cindex types, record
@cindex aggregate type, records
@cindex values, record
@cindex declare record types
@cindex observer record types

@heading About
In  a  tuple, each  component  is  referred using  its  position.  This may  be
error-prone. Record  types allow each  component to  be named. This  makes code
more  readable   because  field  names   have  more  meaning   than  positional
reference. In this sequence, we will  discover how to declare record types, how
to construct record values and how to observe them.


@c .....................................

@node Arrays
@subsection Arrays
@cindex arrays

@heading About
In many  situations, the number  of components of  a composite value  cannot be
determined  at  compile-time.   Arrays  are  data  structures   which  size  is
dynamically computed. This sequence will present the type for arrays as well as
the  syntax to  define array  values and  to observe  their components  through
indices.


@c .....................................

@node Case study --- A small typed database
@subsection Case study: A small typed database
@cindex case study
@cindex database, typed

@heading About
This sequence  is a case  study showing how tuples,  records and arrays  can be
used to implement a toy typed  database. The limits of this implementation will
illustrate the  need for more structured  values. Next week is  about algebraic
datatypes which are an elegant remedy against these limitations.




@c -----------------------------------------------------------------------------
@c                         SECTION: Week 3

@node Week 3 More Advanced Data Structures
@section Week: More Advanced Data Structures
@cindex week 4
@cindex advanced data structures
@cindex data structures, advanced
@cindex algebraic data types
@cindex data types, algebraic
@cindex tags
@cindex recursive data structures
@cindex data structures, recursive
@cindex lists
@cindex hierarchical data structures
@cindex data structures, hierarchical
@cindex parameterized type definitions
@cindex type definitions, parameterized
@cindex type system, advanced features

@heading About
This week, we  will continue our tour  of the OCaml type system.  Last week, we
only defined flat data structures which  are nice to aggregate values but quite
limited when  you try  to structure values.  Algebraic datatypes  offer several
mechanisms to attach  more informative static description of  values using tags
(sequence 0), to define recursive data structures like lists (sequence 1) or to
structure values in a hierarchical way (sequence 2). During sequence 3, we will
discover how programming  is type-directed in OCaml  through the implementation
of a story generator. Type definition can  be made more generic in OCaml thanks
to parameterized type definitions (sequence 4). The final sequence will present
some advanced features of the type system (sequence 5).


@c .....................................

@node Tagged values
@subsection Tagged values
@cindex tagged values

@heading About
In  this sequence,  we will  focus  on list,  an ubiquitous  data structure  in
functional programming. First, we  will see how the type for  lists simply is a
recursive algebraic datatype. Second, the builtin types for list is presented.


@c .....................................

@node Recursive types
@subsection Recursive types
@cindex recursive types
@cindex types, recursive
@cindex lists
@cindex recursive algebraic datatype
@cindex algebraic datatype, recursive

@heading About
In  this sequence,  we will  focus  on list,  an ubiquitous  data structure  in
functional programming. First, we  will see how the type for  lists simply is a
recursive algebraic datatype. Second, the builtin types for list is presented.


@c .....................................

@node Tree-like values
@subsection Tree-like values
@cindex tree-like values
@cindex data structures, tree-like
@cindex hierarchical data structure
@cindex recursive algebraic datatype
@cindex algebraic datatype, recursive

@heading About
In this sequence, we go further  on the topic of recursive datatypes. Tree-like
datastructures are also omnipresent in  computer science because they allow for
a  hierarchical   organization  of   data.  Defining  a   type  for   trees  is
straightforward  in  OCaml  using  a  recursive  algebraic  datatype.  We  will
refactorize  our  typed  database  example  by replacing  arrays  with  such  a
tree-like representation.


@c .....................................

@node Case Study --- A Story Teller
@subsection Case Study: A Story Teller
@cindex case study
@cindex story teller
@cindex story generator
@cindex type-directed programming

@heading About
This sequence is a case study about  the implementation of a story generator. A
story is a typical hierarchical information  (it is composed of event which are
themselves characterized by other values). We will show how the typechecker and
type definitions can guide programming.


@c .....................................

@node Polymorphic algebraic datatypes
@subsection Polymorphic algebraic datatypes
@cindex polymorphic algebraic datatypes
@cindex algebraic datatypes, polymorphic

@heading About
We already  saw that  the type  for list is  parameterized by  the type  of the
elements of  the list. This  polymorphic algebraic datatype is  very convenient
because it improves code reuse: the module List is written once and for all and
provides functions over  lists of any element type. In  this sequence, you will
learn the syntax to define your own parameterized types.


@c .....................................

@node Advanced Topics
@subsection Advanced Topics
@cindex advanced topics
@cindex algebraic datatypes, advanced

@heading About
In this sequence,  we will learn some advanced mechanisms  related to algebraic
datatypes.




@c -----------------------------------------------------------------------------
@c                         SECTION: Week 4

@node Week 4 Higher Order Functions
@section Week 4: Higher Order Functions
@cindex week 4
@cindex higher order functions
@cindex functions, higher order

@heading About
During  this fifth  week  we will  discuss  functions in  OCaml  in their  full
generality.  We will  see that  functions  are in  fact first  class values  in
functional  programming  languages, and  we  will  learn  how to  write  useful
functions on the structured data types that have been introduced in Weeks 2 and
3.


@c .....................................

@node Functional Expressions
@subsection Functional Expressions
@cindex functional expressions

@heading About
In this  sequence we explain  how to  write expressions that  denote functional
values. These correspond  to the so-called lambda-expressions  which also exist
in other programming languages like Python or Java.


@c .....................................

@node Functions as First-Class Values
@subsection Functions as First-Class Values
@cindex functions as first-class values
@cindex functional programming

@heading About
This  sequence explains  a  distinguishing feature  of Functional  Programming:
Functions are First-Class Values,  that is they can be used in  the same way as
any other value.


@c .....................................

@node Functions with Multiple Arguments
@subsection Functions with Multiple Arguments
@cindex functions with multiple arguments

@heading About
In this  sequence we explain that  functions in OCaml are  in reality functions
with one argument  only, and that functions with several  arguments are just an
abbreviation for nested functions with one argument only.


@c .....................................

@node Partial Function Application
@subsection Partial Function Application
@cindex partial application
@cindex partial function application

@heading About
This sequence explores a  consequence of what we have learned  in Sequence 2: a
function  with several  arguments  may  be applied  to  some  of its  arguments
only.  We  show at  hand  of  an example  how  to  put this  so-called  Partial
Application into use.


@c .....................................

@node Mapping Functions on Lists
@subsection Mapping Functions on Lists
@cindex mapping functions on lists
@cindex map

@heading About
This sequence introduces the function Map  which allows you to transform a list
by applying the same function to all elements of the list.


@c .....................................

@node Folding Functions on Lists
@subsection Folding Functions on Lists
@cindex folding functions on lists

@heading About
This sequence introduces  two different folding functions on  lists. Both allow
us to combine the elements of a list using a binary operator.




@c -----------------------------------------------------------------------------
@c                         SECTION: Week 5

@node Week 5 Exceptions Input/Output And Imperative Constructs
@section Week 5 Exceptions, Input/Output And Imperative Constructs
@cindex week 5
@cindex exceptions
@cindex input/output
@cindex io
@cindex imperative constructs

@heading About
Exploring the imperative features offered by the OCaml language.


@c .....................................

@node Imperative features in OCaml
@subsection Imperative features in OCaml
@cindex imperative features

@heading About
In this sequence, we remark that  sometimes imperative features are useful, and
dress a list of the ones we see this week.


@c .....................................

@node Getting and handling your Exceptions
@subsection Getting and handling your Exceptions
@cindex exceptions

@heading About
Exceptions  are useful  to alter  the  flow of  control, capture  all kinds  of
errors, and handling  them.  In this sequence, we meet  the exception mechanism
offered by OCaml, and learn to use it at our advantage.


@c .....................................

@node Getting Information In And Out
@subsection Getting Information In And Out
@cindex input/output

@heading About
Reading from  the input and  writing to the output  can be performed  easily by
using some other very useful imperative features.


@c .....................................

@node Sequences and iterations
@subsection Sequences and iterations
@cindex sequences and iterations

@heading About
Once we have imperative constructs at  hand, executing them one after the other
is a must. We  learn here the special syntax we have at  hand in OCaml for this
task.


@c .....................................

@node Mutable arrays
@subsection Mutable arrays
@cindex Mutable arrays

@heading About
Now we meet  data structures that are  modifiable in place. We  will start from
the arrays, as we  find out that thay can actually be  modified, like arrays in
most other programming languages.


@c .....................................

@node Mutable record fields
@subsection Mutable record fields
@cindex mutable record fields

@heading About
In  OCaml, it  is possible  to have  a fine  control on  which part  of a  data
structure  can  be modified  in  place,  in  the  imperative style,  and  which
cannot. Time to meet the mutable record fields!


@c .....................................

@node Variables, aka References
@subsection Variables, aka References
@cindex variables, aka references
@cindex references

@heading About
Variables? You  want variables? Yes,  you can have  them! One can  simulate the
usual  imperative variables  by using  identifiers  and a  record with  mutable
fields.




@c -----------------------------------------------------------------------------
@c                         SECTION: Week 6

@node Week 6 Modules And Data Abstraction
@section Modules And Data Abstraction
@cindex week 6
@cindex modules
@cindex module system
@cindex data abstraction, modules
@cindex type abstraction
@cindex interfaces
@cindex functors
@cindex compilation process

@heading About
This last installment of the course is about programming-in-the-large using the
module system of OCaml. When a piece  of software reaches a level of complexity
that  requires several  programmers  to develop  together,  new mechanisms  are
needed  to  structure programming.  Module  implementations  must be  organized
hierarchically and  hidden behind  interfaces (sequence 0).  Information hiding
must be enforced  by the type abstraction  (sequence 1). A case  study will put
these mechanisms at work through the  developement of a module for dictionaries
(sequence 2). Functors  are a powerful mechanism to a  parameterize module with
respect to a family of modules  described by a signature (sequence 3). Finally,
the final sequence will present the  compilation process of OCaml and the tools
that  ease the  creation of  software made  of compiled  modules and  libraries
(sequence 4).


@c .....................................

@node Structuring software with modules
@subsection Structuring software with modules
@cindex modules

@heading About
Value  and type  definitions  can be  regrouped  into modules.  A  module is  a
software component which has an internal consistency and provides some services
through  an interface.  OCaml takes  modules  seriously: not  only it  provides
syntax to  define module  implementations and  interfaces, but  the typechecker
statically checks  that that modules  are properly  used. In this  sequence, we
present the syntax of module implementations and interfaces.


@c .....................................

@node Information hiding
@subsection Information hiding
@cindex information hiding
@cindex interface
@cindex type abstraction

@heading About
The purpose  of an interface  is to publish  the minimal amount  of definitions
needed to use a  module. Hiding everything that is not  necessary to the module
client is very important to  reduce the interdependencies between modules. Type
abstraction is a powerful mechanism to enforce information hiding.


@c .....................................

@node Case Study --- A Module For Dictionaries
@subsection Case study: A module for dictionaries
@cindex case study dictionaries

@heading About
In this sequence, we discuss the design of a module for dictionaries.


@c .....................................

@node Functors
@subsection Functors
@cindex functors

@heading About
Functors are functions from modules to modules.  In other words, a functor is a
module  parameterized by  another  module.  In this  sequence,  the syntax  for
functors is explained.


@c .....................................

@node Modules as compilation units
@subsection Modules as compilation units
@cindex compilation units
@cindex compilation tools

@heading About
In  this  final  sequence,  we  present the  compilation  tools  of  the  OCaml
ecosystem.





@c -----------------------------------------------------------------------------
@c                         SECTION: Week 7

@node Week 7 Project
@section Week 7: Project
@cindex project

@heading About
This last chapter presents the practical  programming project that is worth 40%
of the final grade.

You can choose between two options.

@cindex Solver for Klotski, project
@cindex project, Solver for Klotski
@enumerate
@item
The first,  @emph{A Solver for Klotski},  will have you write  a generic solver
for puzzle  games, and then  instanciate it to solve  the game of  Klotski. You
will be rewarded with  an animation of your solution!  It  should be noted that
this project uses vocabulary and concepts that make it more suited for computer
science students.

@cindex random text generation, project
@cindex project, random text generation
@item
In the  second, @emph{Random Text  Generation}, you  will write a  program that
uses a Markov chain  approach (yes, the same Markov chains as  in TV series) to
generate random  sentences that  reuse parts  of an input  text (or  even mixes
parts of several ones). You will be rewarded with lots of funny sentences! This
project is a bit easier and has less prerequisites.

@end enumerate

So have  a look at both  texts and choose the  one you prefer! You  can also do
both, but it won't give you extra points.


@c .....................................

@node A Solver For Klotski
@subsection A Solver For Klotski
@cindex A Solver For Klotski

@heading About
Klotski  is  a  sliding block  puzzle,  that  has  a  fairly detailed  page  on
WikiPedia. The purpose of this project is to write a solver for Klotski using a
graph exploration algorithm.

@subheading The Problem
The  Klotski puzzle  is  made of  a  board  of 4x5  places  which contains  the
following 10 pieces:

@itemize
@item
one 2x2 square piece (written @code{S})

@item
one 2x1 horizontal rectangle piece (written @code{H})

@item
four 1x2 vertical rectangle pieces (written @code{V0}, @code{V1}, @code{V2} and
@code{V3})

@item
four 1x1 square pieces (written @code{C0}, @code{C1}, @code{C2}, @code{C3}).
@end itemize

@subheading Initial Configuration
The  puzzle is  presented in  the initial  configuration that  is shown  in the
following picture:

@subheading A Move
A move  in this puzzle consists  in sliding a piece  at a time, and  to win you
must have managed to  move the large square piece all the  way down, reaching a
configuration that matches the following shape pattern:

@subheading How To Solve
To  solve  the puzzle,  one  may  search all  its  state  space for  a  winning
configuration. The  state space  of the  Klotski puzzle can  be described  as a
graph,  having as  nodes the  configurations of  the board,  and as  arrows the
possible moves.

@subheading Excerpt
In the  following picture, we  show an excerpt  of the Klotski  graph, starting
from  the initial  configuration. All  the  boards reachable  from the  initial
configuration in one step  are shown, as well as a few  of the boards reachable
in two steps.

@subheading Avoiding Repetitions
Since all  moves can be undone,  it is easy to  see that one can  move from any
configuration of the graph to any  other configuration of the graph. This means
that,  when exploring  the  graph, one  will naturally  pass  through the  same
configuration more than once, following  different paths. To avoid spending our
time running in  circles when searching for  a solution, we will  need to avoid
visiting a configuration more than once!

@heading Approach
To solve the Klotski puzzle, you will proceed in two steps:

@enumerate A
@item
As a first step,  you will write a generic solver for  any problem whose search
space can be represented by a graph,  and making sure you handle properly loops
in the graph.

@item
As a second step, you will describe the Klotski puzzle search space as a graph.

@end enumerate

Once the two steps above are done, finding  a solution will just be a matter of
passing the Klotski graph to the generic solver.

@cartouche
@b{Note}: this project may take quite a lot of time to be graded, because it is
long,  and because  the algorithm  is  complex.  We  suggest that  you use  the
typecheck button and the toplevel extensively, so that you are reasonnably sure
of your  code before  submitting it  to the  tests. Also,  we added  a function
grade_only :  int list -> unit,  that you may call  in your code to  select the
exercises to grade. All other exercises  won't be graded at all, and considered
failed. For instance, if you write grade_only [ 3 ] ;; at the beginning of your
file, only exercise 3 will be tested.
@end cartouche


@c .....................................

@node Random Text Generation
@subsection Random Text Generation
@cindex project, random text genration

@heading About
The goal  of this  project is  to synthesize  natural language  sentences using
information extracted from an existing text corpus.

For this, given a text corpus as  input, we will first compute the frequency of
all  sequences of  two  words in  the  original  text; then  we  will use  this
information to produce new sentences by randomly collating these sequences with
the same frequencies.

@cindex Markov chain
This method is known under the term of @dfn{Markov chain}. From the input text,
we compute a  transition table that associates  to each word the  list of words
that may appear after it, with their relative frequencies.

@subheading Example
For instance, if we examine ”I am a man and my dog is a good dog and a good dog
makes  a good  man”, delimiting  it  with ”START”  and ”STOP”  to identify  the
beginning and end of  the sentence, we end up with the  transition table on the
right.

This table can then  be used to generate new text that  ressembles the input in
the following way: starting from the "START" word, choose one of the words that
may appear  after it, with the  probability found in  the table, add it  to the
output, then iterate the process until the "STOP" word is found. Below are some
example sentences produced using this table.

@verbatim
START I am a good  man STOP ; START I am a good dog  is a good dog and
my dog and my  dog is a man and my  dog and a man STOP ;  START I am a
good dog is a man and my dog makes a good man STOP ; START I am a good
dog makes a good dog is a good dog  and a good dog makes a good dog is
a man STOP ; START I am a good dog and a man and a good dog and a good
man and a good dog is a good dog  is a good man and a man STOP ; START
I am a good dog and a good dog and my dog is a man STOP ; START I am a
man STOP ;  START I am a good dog  is a good dog is a  good dog and my
dog is a man STOP ; START I am a good man STOP ; START I am a good dog
makes a good dog and a good dog is a good dog is a good man and my dog
is a good dog and  my dog and a good man and a good  dog is a good man
STOP ; START I am a man and my dog and my dog is a good dog and a good
dog makes a man STOP
@end verbatim

@heading The Project
This project is decomposed in three parts.

@enumerate A
@item
First, we will build  a quick prototype, that goes from an  input sentence to a
randomly generated sentences via a distribution table as the ones above.

@item
Then we will use  better data structures to enhance the  performance so that we
can use larger texts, such as small books, as input.

@item
After that, we will enhance the quality  of input and output, by analysing in a
smarter way  the input text corpus,  and by considering sequences  of more than
two words.
@end enumerate

@cartouche
Note: this project may  take more time to be graded, because  it is longer than
simple exercises, and because it is tested on large inputs. We suggest that you
use  the  typecheck button  and  the  toplevel  extensively,  so that  you  are
reasonnably sure of your code before submitting it to the tests. Also, we added
a function  grade_only : int list  -> unit, that you  may call in your  code to
select the exercises to grade. All other  exercises won't be graded at all, and
considered  failed. For  instance, if  you write  grade_only [  3 ]  ;; at  the
beginning of your file, only exercise 3 will be tested.
@end cartouche


@c END CHAPTER OcamlMOOC
@c /////////////////////////////////////////////////////////////////////////////


@c END CHAPTERS
@c /////////////////////////////////////////////////////////////////////////////








@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN APPENDICES
@c --The Makefile
@c --Code Chunk Summaries
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






@c <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
@part Appendices
@c <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>






@c *****************************************************************************
@c                              THE MAKEFILE

@node The Makefile
@appendix The Makefile
@cindex makefile

The @file{Makefile} has five initial top-level targets built in as defaults:

@enumerate

@item
Variable Definitions

@itemize
@item
FILE: the name of this source document, without extension
@item
ROOT: the  name of the  root directory, which  defaults to the  present working
directory, $(PWD)
@item
FILES: the  name of  the root directory  for the files  created in  this source
document, which defaults to @file{files}
@item
LODESTONE: a reference file to help @file{Makefile} determine when to recompile
this source document or the @file{TEXI} file
@end itemize

@item
The Default Target: @command{twjr}, described below

@item
The TWJR Targets

@table @command
@item twjrkeep
@command{jrtangle jrweave info pdf html}
@item twjr
@command{twjrkeep dirclean}
@item jrtangle
@command{jrtangle $(FILE).twjr}
@item jrweave
@command{jrweave $(FILE).twjr > $(FILE).texi}
@item dist
@command{jrtangle $(FILE).twjr jrweave $(FILE).twjr > $(FILE).texi distclean}
@item newmakefile
@command{jrtangle allclean}
@end table

@item
The Clean Targets

@enumerate
@item
Clean
@item
Dirclean
@item
Distclean
@item
Allclean
@end enumerate

@item
The Applications Hook

@end enumerate




@(Makefile@)=
# MAKEFILE FILE CHUNKS
######################

@<Makefile---Variable Definitions@>
@<Makefile---Default Target@>
@<Makefile---TWJR Targets@>
@<Makefile---Clean Targets@>
@<Makefile---Applications@>

@




@c -----------------------------------------------------------------------------

@node Makefile Variable Definitions
@appendixsec Makefile Variable Definitions

The @env{SHELL} variable is included because some shell commands depend upon
Bash version 4, which is not native on my system.

The @env{ROOT} variable is designed to allow you to to extract the source files
(not the @acronym{TEXI}, @acronym{INFO}, @acronym{PDF} or @acronym{HTML} files,
but  the  programs defined  inside  the  @acronym{TWJR}  file) to  a  directory
structure outside of the your  ``present working directory'' (@env{PWD}) should
that be something you want to do, i.e., for production purposes.

The @code{FILE} variable  is the name of this source  @code{TWJR} file, without
extension.

The @code{FILES} variable is the name of  the root directory for the files that
are extracted during the @emph{tangling} phase.  This directory goes underneath
the @file{ROOT} directory.  Feel free to name this whatever you want.

The @code{LODESTONE}  variable is an empty  reference file that is  used solely
for its  modification time  to help  the Makefile  determine when  to recompile
(i.e., @emph{tangle} and @emph{weave}) the  source @file{TWJR} file.  It should
not be changed or otherwise touched (pun intended).

@<Makefile---Variable Definitions@>=
# VARIABLE DEFINITIONS
######################
LODESTONE := .lodestone
README    := README.md
GIT       := .git*

SHELL := $$(which bash)

FILE  := OCaml
ROOT  := $(PWD)
FILES := files

@




@c -----------------------------------------------------------------------------

@node Makefile Default Target
@appendixsec Default Target
@cindex default target

The @code{default} target  extracts all source files and moves  them into their
proper  directories,  and  processes  the   @code{TEXI}  source  file  into  an
@code{INFO}  file, a  @code{PDF} document,  and an  @code{HTML} web  site. This
process automatically updates the TEXI's nodes and sectioning commands prior to
generating  the   INFO,  PDF,  and   HTML  documents.    What  used  to   be  a
manually-intensive process is now completely  automated through a Makefile that
is extracted from the @code{TWJR}  source.

This  automated  process  depends   upon  the  programmer's  system  containing
@file{GNU   AWK}  (for   the   primary  literate   programming  operations   of
@emph{tangling}   and   @emph{weaving}@footnote{No  other   implementation   of
@file{AWK}  will  work}),   @file{make}  (to  control  the   build  and  output
processes@footnote{While I haven't tested it, just about any @file{make} should
work}),  @file{Texinfo} of  at least  version 6.5  (for the  processing of  the
@file{TEXI} output file), @file{makeinfo} (to produce the @file{INFO} file from
the @file{TEXI}  file), and @file{Emacs}  (for the automatic updating  of nodes
and sectioning  command@footnote{Again, while I  haven't tested it,  just about
any @file{Emacs}  should work}).   With these  dependencies, everything  can be
compiled with a single call to @command{make} with no argument:

@example
$ make
@end example

Individual files and documents can also be targeted with simple calls such as:

@example
$ make html

$ make openhtml

$ make pdf

$ make openpdf

$make info

$ make openinfo

$ make distclean

$ make allclean
@end example

@noindent and so forth (just name a few).

The target  @code{twjr} is  the default, and  does everything  explicitly.  The
target @code{weave}  (or alternatively @code{texi})  will run just  the command
@command{jrweave}  on the  @file{TWJR} file  to produce  the @file{TEXI}  file,
which  is  directly  responsible  for  producing  the  output  files.   If  the
@file{TWJR}  source  file has  been  modified,  then @command{maked}  will  run
@command{jrtangle} first to update all source documents.

@<Makefile---Default Target@>=
# DEFAULT Target
################
.PHONY : TWJR JRTANGLE TANGLE JRWEAVE WEAVE TEXI INFO PDF HTML
.PHONY : default twjr twjrkeep jrtangle tangle
.PHONY : jrweave weave texi info pdf html newmakefile

default : TWJR

@




@c -----------------------------------------------------------------------------

@node Makefile TWJR Targets
@appendixsec TWJR Targets
@cindex TWJR targets

These targets are all related to processing the main source @acronym{TWJR} file
in some  way. The @file{make} target  @command{twjr} is the default  target and
runs each of the processes  @command{jrtangle} and @command{jrweave} to produce
source files,  a @acronym{TEXI} file,  an @acronym{INFO} file,  a @acronym{PDF}
document, and an @acronym{HTML} web site.  It only sources what is necessary as
@file{make} is designed to do.  Note that at this time, @emph{weaving} includes
automatic  menu and  node  updating  of the  @acronym{TEXI}  file,  so that  an
@acronym{INFO} file  can also be  generated without needing to  manually update
the  @acronym{TEXI} file  first  as used  to be  the  case. @file{make}  target
@code{info}     runs     @command{makeinfo},     target     @code{pdf}     runs
@command{pdftexi2dvi}, and target @code{html} runs @command{makeinfo --html}.

The default @file{twjr} target deletes all extraneous build and log files prior
to finishing.   If you want  to retain  the build and  log files, then  run the
target @file{twjrkeep} instead.

The  file  @file{.lodestone}   is  used  to  set  a  reference   time  for  the
@acronym{TWJR} file,  so that  if the @acronym{TWJR}  file changes,  new source
documents will be generated; otherwise, it  will simply be left alone. In other
words, if @file{.lodestone}  is older than @file{.twjr},  then @file{.twjr} has
been modified, and it should be @emph{tangled} and @emph{woven} first.  If it is
newer, then @command{make} will not recompile.

Should the @file{Makefile}  portion of the @file{TWJR} be modified,  then it is
important to  obtain a fresh copy  of the @file{Makefile} prior  to running any
target; therefore,  use the target  @command{make newmakefile} first,  then run
any desired target.

@<Makefile---TWJR Targets@>=
# TWJR TARGETS
##############

# <------------------------------------->
#               twjrkeep


# Process everything; don't remove any build or log files;

twjrkeep : jrtangle jrweave info pdf html


# <------------------------------------->
#                 TWJR
#                DEFAULT

# Process everything; remove build files and logs.

TWJR : twjr
twjr : twjrkeep dirclean


# <------------------------------------->
#               JRTANGLE

# JRTANGLE depends upon the LODESTONE and the ROOT/FILES directory;
# if either is missing or out of date, then JRTANGLE will be run to
# extract its files.

JRTANGLE : TANGLE
TANGLE   : jrtangle
jrtangle : tangle
tangle   : files $(LODESTONE)

@

@anchor{LODESTONE}
@<Makefile---TWJR Targets@>=
# <------------------------------------->
#               LODESTONE

# Checks the relative time to determine if JRTANGLE should be rerun

$(LODESTONE) : $(FILE).twjr
	@printf "${YELLOW}Tangling $(FILE)...${CLEAR}\n"
	@jrtangle $(FILE).twjr
	@touch $(LODESTONE)
	@printf "${GREEN}done tangling.${CLEAR}\n"


# <------------------------------------->
#                files

# Checks for  the existence  of the ROOT/FILES  directory; extracts  files into
# them if they don't  exist or are out of date; they must  be retouched if they
# exist but  are out of date  because they will  not be remade or  updated when
# files are extracted into them

files : $(ROOT)/$(FILES)
$(ROOT)/$(FILES) : $(FILE).twjr
	@printf "${YELLOW}Creating files...${CLEAR}\n"
	@touch $(FILE).twjr
	@make $(LODESTONE)
	@touch $(ROOT)/$(FILES)
	@printf "${GREEN}done creating files.${CLEAR}\n"


# <------------------------------------->
#              newmakefile

# Extracts the Makefile if necessary by tangling; everything else
# is thereafter deleted

newmakefile : $(LODESTONE) allclean


# <------------------------------------->
#              JRWEAVE

# Extracts the TEXI, and updates the nodes and sections with a batch call to
# Emacs; it depends upon TWJR

JRWEAVE : WEAVE
WEAVE   : TEXI
TEXI    : jrweave
jrweave : weave
weave   : texi
texi    : $(FILE).texi
$(FILE).texi : $(FILE).twjr
	@printf "${YELLOW}Weaving $(FILE)...${CLEAR}\n"
	@jrweave $(FILE).twjr > $(FILE).texi
	@printf "${GREEN}done weaving.${CLEAR}\n";
	@printf "${YELLOW}updating $(FILE)'s menus and nodes...${CLEAR}\n"
	@emacs --batch --eval '(progn (find-file "./$(FILE).texi" nil) \
	  (texinfo-master-menu 1) (save-buffer 0))' 2> batch.log
	@printf "${GREEN}done updating.${CLEAR}\n"

# <------------------------------------->
#                DIST

DIST : dist
dist : jrtangle jrweave distclean


# <------------------------------------->
#                 INFO
#               OPENINFO

# Runs makeinfo on the TEXI file;
# Opens the INFO file in Emacs

INFO : info
info : $(FILE).info
$(FILE).info : $(FILE).texi
	@printf "${YELLOW}Creating an INFO file...${CLEAR}\n"
	@makeinfo $(FILE).texi
	@printf "${GREEN}done${CLEAR}\n"
openinfo : INFO
	@printf "${YELLOW}Opening INFO in Emacs...${CLEAR}\n"
	@emacsclient -s server --eval \
	    '(progn \
	        (info "$(ROOT)/$(FILE).info") \
	        (revert-buffer t t))'
	@printf "${GREEN}done${CLEAR}\n"


# <------------------------------------->
#                  PDF
#                OPENPDF

# Runs pdftexi2dvi on the TEXI file;
# Opens the PDF file

PDF : pdf
pdf : $(FILE).pdf
$(FILE).pdf : $(FILE).texi
	@printf "${YELLOW}Creating a PDF file...${CLEAR}\n"
	@pdftexi2dvi --build=tidy --build-dir=build --quiet $(FILE).texi
	@printf "${GREEN}done${CLEAR}\n"
openpdf : PDF
	@printf "${YELLOW}Opening PDF...${CLEAR}\n"
	@open $(FILE).pdf
	@printf "${GREEN}done${CLEAR}\n"


# <------------------------------------->
#                 HTML
#               OPENHTML

# Runs makeinfo --html on the TEXI file;
# Opens index.html in a browser

HTML : html
html : $(FILE)/index.html
$(FILE)/index.html : $(FILE).texi
	@printf "${YELLOW}Creating an HTML directory...${CLEAR}\n"
	@makeinfo --html $(FILE).texi
	@printf "${GREEN}done${CLEAR}\n"
openhtml : HTML
	@printf "${YELLOW}Opening INDEX.HTML in the browser...${CLEAR}\n"
	@open $(FILE)/index.html
	@printf "${GREEN}done${CLEAR}\n"

@




@c -----------------------------------------------------------------------------

@node Makefile Clean Targets
@appendixsec Makefile Clean Targets
@cindex Makefile clean targets

The @command{clean} target removes  backup files. The @command{dirclean} target
removes build  directories and log  files, but  not source files  (those inside
@file{files} directory,  e.g., @file{bin/} and and  @file{src/}) and associated
files and  programs inside  them.  The  @command{distclean} target  removes the
@acronym{INFO}, @acronym{PDF},  @acronym{HTML}, and @acronym{source}  files and
directories, leaving just  the @file{TWJR} file, the @file{TEXI}  file, and the
@file{Makefile}.  Finally,  the  @command{allclean} target  removes  everything
except the @acronym{TWJR} file and the @file{Makefile}.

@<Makefile---Clean Targets@>=
# CLEAN TARGETS
################
.PHONY : clean dirclean distclean allclean

# <------------------------------------->
#                clean

# remove backup files

clean :
	@printf "${WHITEBOLD}Cleaning...${CYAN}\n"
	@rm -f *~ .*~ #*#
	@printf "${GREEN}done cleaning.${CLEAR}\n"


# <------------------------------------->
#               dirclean

# after clean:  remove all  build and miscellaneous  files, leaving  only TWJR,
# TEXI,  INFO, HTML,  PDF,  Makefile,  README, .git,  .gitignore  & the  source
# documents.

dirclean : clean
	@printf "${WHITEBOLD}Dir-cleaning...${CYAN}\n"
	@for file in * .*; do      \
	  case $$file in           \
            '.' | '..')          ;;\
	    $(FILE)* | Makefile) ;;\
	    $(FILES)*)	 	 ;;\
	    $(LODESTONE))        ;;\
	    $(README))		 ;;\
	    $(GIT))		 ;;\
	    *) rm -vfr $$file	 ;;\
	  esac                     \
	done
	@printf "${GREEN}done dir-cleaning.${CLEAR}\n"


# <------------------------------------->
#                distclean

# after dirclean: remove INFO, HTML, and PDF, and FILES

distclean : dirclean
	@printf "${WHITEBOLD}Dist-cleaning...${CYAN}\n"
	@rm -vfr $(FILE) $(FILE).info $(FILE).pdf $(ROOT)/$(FILES)
	@printf "${GREEN}done dist-cleaning.${CLEAR}\n"


# <------------------------------------->
#                allclean

# allclean: remove TEXI, leaving only TWJR and Makefile

allclean : distclean
	@printf "${WHITEBOLD}Cleaning all...${CYAN}\n"
	@rm -vfr $(FILE).texi
	@printf "${GREEN}done cleaning all.${CLEAR}\n"

@




@c -----------------------------------------------------------------------------

@node Makefile Applications
@appendixsec Makefile Applications
@cindex Makefile applications

Place any targets for running  code-specific commands here, such as executables
in the @file{bin/} directory.  The file @verb{|@<Makefile---Applicaionts@>|} is
a hook  that can  be used in  another part  of the source  document; this  is a
fundamental feature of literate programming.

@<Makefile---Applications@>=
# APPLICATION TARGETS
######################

# <Makefile---Applications--Hook>

@


@c END The Makefile
@c /////////////////////////////////////////////////////////////////////////////







@c *****************************************************************************
@c                        CODE CHUNK SUMMARIES

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu




@c -----------------------------------------------------------------------------
@node File Definitions
@appendixsec Source File Definitions

@print_file_defs




@c -----------------------------------------------------------------------------
@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs




@c -----------------------------------------------------------------------------
@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs


@c END Code Chunk Summaries
@c /////////////////////////////////////////////////////////////////////////////







@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
@c BEGIN END MATTER
@c --Bibliography
@c --Tables
@c --Indices
@c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






@c <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
@part Back Matter
@c <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>






@c *****************************************************************************
@c                                BIBLIOGRAPHY

@node @mybibnode{}
@unnumbered Bibliography

@table @asis

@mybibitem{LitProg:Home}
"On Misreadings", email, January 2009 @url{http://www.literateprogramming.com/}

@mybibitem{LitProg:Knuth}
@url{``Literate Programming (1984)'' in Literate Programming. CSLI, 1992, pg.
99.}

@mybibitem{LitProg:Ramsey}
@url{ahttps://www.cs.tufts.edu/~nr/noweb/}

@end table


@c END Bibliography
@c /////////////////////////////////////////////////////////////////////////////







@c *****************************************************************************
@c                             LIST OF TABLES

@node List of Tables
@unnumbered List of Tables

@listoffloats Table


@c END Lists
@c /////////////////////////////////////////////////////////////////////////////







@c  *****************************************************************************
@c                               CONCEPT INDEX

@node Concept Index
@unnumbered Index

@printindex cp


@c END Indices
@c /////////////////////////////////////////////////////////////////////////////








@bye

TODO:
